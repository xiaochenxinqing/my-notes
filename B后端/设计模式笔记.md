# 设计模式笔记

**======程序设计七大原则======**

单一职责（类 方法只干一件事）

开闭原则（对扩展开放，对修改关闭）

依赖倒置（针对接口编程，依赖于抽象而不依赖于具体。）

接口隔离（使用多个隔离的接口，比使用单个接口要好）

里氏替换  (基类可以出现的地方，子类一定可以出现)

迪米特法则（最少知道原则，个实体应当尽量少的与其他实体之间发生相互作用）

合成/聚合复用原则（尽量使用合成/聚合的方式，而不是使用继承）

**====23种设计模式=====**

**最常用的几种：**[https://blog.csdn.net/yubujian_l/article/details/81455524](https://blog.csdn.net/yubujian_l/article/details/81455524)

**创建型（抽工建原单）**

抽象工厂模式 [http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html](http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html)

<span style="background-color: #ffaaaa">工厂方法</span> [http://www.cnblogs.com/java-my-life/archive/2012/03/25/2416227.html](http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html)

<span style="background-color: #ffaaaa">建造者模式</span>  [http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html](http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html) **工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性**。

原型模式 [http://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html](http://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html)

<span style="background-color: #ffaaaa"><span style="background-color: #ffaaaa">单例模式</span></span> [http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html](http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html)

**结构型（桥外组装享饰代）**

<span style="background-color: #ffaaaa">适配器模式</span> [http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html](http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html) **适配器模式是将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的的类的兼容性问题。主要分三类：类的适配器模式、对象的适配器模式、接口的适配器模式。**

桥接模式 [http://blog.csdn.net/jason0539/article/details/22568865](http://blog.csdn.net/jason0539/article/details/22568865)

组合模式 [http://blog.csdn.net/jason0539/article/details/22642281](http://blog.csdn.net/jason0539/article/details/22642281)

外观模式 [http://blog.csdn.net/jason0539/article/details/22775311](http://blog.csdn.net/jason0539/article/details/22775311)

<span style="background-color: #ffaaaa">装饰者模式</span> [http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html](http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html)   **装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。**

享元模式 [http://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html](http://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html)

<span style="background-color: #ffaaaa"><span style="background-color: #ffaaaa">代理模式</span></span> [http://www.cnblogs.com/java-my-life/archive/2012/04/23/2466712.html](http://www.cnblogs.com/java-my-life/archive/2012/04/23/2466712.html) **代理模式指给一个对象提供一个代理对象，并由代理对象控制对原对象的引用。代理可以分为静态代理和动态代理。**

**通过代理模式，可以利用代理对象为被代理对象添加额外的功能，以此来拓展被代理对象的功能。可以用于计算某个方法执行时间，在某个方法执行前后记录日志等操作。**

**行为型（迭责命解 模访观策状备中 ）**

迭代模式 [http://www.cnblogs.com/java-my-life/archive/2012/05/22/2511506.html](http://www.cnblogs.com/java-my-life/archive/2012/05/22/2511506.html)

<span style="background-color: #ffaaaa">**责任链模式**</span> [https://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html](https://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html)  **在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。（击鼓传花，自己里面有个自己的属性）**

命令模式 [http://www.cnblogs.com/java-my-life/archive/2012/06/01/2526972.html](http://www.cnblogs.com/java-my-life/archive/2012/06/01/2526972.html) **　命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。**

解释器模式 [http://www.cnblogs.com/java-my-life/archive/2012/06/19/2552617.html](http://www.cnblogs.com/java-my-life/archive/2012/06/19/2552617.html)

模板方法模式 [http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html](http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html)

访问者模式 [http://www.cnblogs.com/java-my-life/archive/2012/06/14/2545381.html](http://www.cnblogs.com/java-my-life/archive/2012/06/14/2545381.html)

<span style="background-color: #ffaaaa">观察者模式</span><span style="background-color: #ffaaaa"> </span>[http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html](http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html)

**观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己（先登记，再通知）**

<span style="background-color: #ffaaaa">策略模式</span> [http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html](http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html)（ **策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化**）

状态模式 [http://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html](http://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html)

备忘录模式 [http://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html](http://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html)

中介者模式 [http://blog.csdn.net/chenhuade85/article/details/8141831](http://blog.csdn.net/chenhuade85/article/details/8141831)

<span style="background-color: #ffaaaa">

</span>

# **适配器模式，装饰模式，代理模式的区别:**

[https://juejin.cn/post/7073443652306993189](https://juejin.cn/post/7073443652306993189)

<span style="background-color: #ffaaaa">

</span>
